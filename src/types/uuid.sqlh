#if 0 /* don't emit the modeline, it could break stuff */
-- vim: ff=unix fenc=utf-8 tw=0 ts=4 sts=0 sw=4 noet ai fdm=marker
#endif
#ifndef _ssat_Types_UUID
#define _ssat_Types_UUID
	#if defined(_ssat_DBMS_PG) /*{{{ PostgreSQL */
		create extension if not exists "uuid-ossp";
		#define uuid_to_char(victim) victim::text
		#define uuid_to_hex(victim) replace((victim::text),'-','')
		#define char_to_uuid(victim) victim::uuid
		#define NewID() uuid_generate_v4()
	/*}}}*/
	#elif defined(_ssat_DBMS_Maria) /*{{{ MariaDB */
		#define UUID binary(16)
		/* redefine the delimiter because MySQLish quoting/escaping is a pain in the behind */
		SETDELIM(!!!,;)
		create function uuid_to_char(/*in*/ victim UUID) returns char(36) /*{{{*/
			language sql
			contains sql
			deterministic
			sql security invoker
			comment 'Turn a 16-byte binary UUID into a formatted text hex-with-dashes UUID'
			return lcase(concat_ws('-',
					substring(hex(victim), 1,8), -- first group
					substring(hex(victim), 9,4),
					substring(hex(victim),13,4),
					substring(hex(victim),17,4),
					substring(hex(victim),21,12)
				));
			!!! /*}}}*/
		create function uuid_to_hex(in victim UUID) returns char(32) /*{{{*/
			language sql
			contains sql
			deterministic
			sql security invoker
			comment 'Turn a 16-byte binary UUID into a hex string'
			return lcase(hex(victim));
			!!! /*}}}*/
		create function char_to_uuid(in victim varchar(36)) returns UUID /*{{{*/
			language sql
			contains sql
			deterministic
			sql security invoker
			comment 'Turn a human-readable text UUID into a 16-byte binary value'
			return unhex(replace((victim),'-',''));
			!!! /*}}}*/
		create function NewID() returns UUID /*{{{*/
			language sql
			contains sql
			not deterministic -- calls uuid() internally
			sql security invoker
			comment 'Create a new 16-byte binary UUID'
			return char_to_uuid(uuid());
			!!! /*}}}*/
		SETDELIM(;,!!!)
		/* delimiter is now fixed */

		/*{{{ UUID_MKDEFAULT must have SETDELIM called around it to set & restore the quotes */
		#define UUID_MKDEFAULT(victbl,viccol,intdelim,enddelim) create trigger trg_ ## victbl ## _ ## viccol ## _uuid_defval \
			before insert on victbl for each row begin if new.viccol is null then set new.viccol = NewID() intdelim \
			end if intdelim end enddelim
		/*}}}*/
	/*}}}*/
	#elif defined(_ssat_DBMS_FBird) /*{{{ Firebird */
		create domain uuid as char(16) character set octets;
		-- uuid_to_char already defined
		#define uuid_to_hex(victim) (victim)
		-- char_to_uuid already defined
		#define NewID() gen_uuid()

		/*{{{ UUID_MKDEFAULT must have SETDELIM called around it to set & restore the quotes */
		#define UUID_MKDEFAULT(victbl,viccol,intdelim,enddelim) create trigger trg_ ## victbl ## _ ## viccol ## _uuid_defval \
			active before insert on victbl as begin if new.viccol is null then set new.viccol = NewID() intdelim \
			end if intdelim end enddelim
		/*}}}*/
	/*}}}*/
	#elif defined(_ssat_DBMS_MSSQL) /*{{{ Microsoft SQL Server */
		#define UUID uniqueidentifier
		-- UUID encode/decode TBD
		-- NewID() is stock
	/*}}}*/
	#elif defined(_ssat_DBMS_SQLite) /*{{{ SQLite */
		/*{{{ MASSIVE UGLY KLUDGE */
		-- h is the PKey since it's the only one we join on
		create table if not exists _sqlite_unhexhack_lookup_tbl (
			h text(2) collate nocase not null primary key check(length(h) = 2 AND h = hex(b)),
			b blob(1) not null unique check(length(b) = 1)
		) without rowid;
		-- next statement generated by a Perl script
		insert or ignore into _sqlite_unhexhack_lookup_tbl values('00',X'00'),('01',X'01'),('02',X'02'),('03',X'03'),('04',X'04'),
			('05',X'05'), ('06',X'06'), ('07',X'07'), ('08',X'08'), ('09',X'09'), ('0A',X'0A'), ('0B',X'0B'), ('0C',X'0C'), ('0D',X'0D'),
			('0E',X'0E'), ('0F',X'0F'), ('10',X'10'), ('11',X'11'), ('12',X'12'), ('13',X'13'), ('14',X'14'), ('15',X'15'), ('16',X'16'),
			('17',X'17'), ('18',X'18'), ('19',X'19'), ('1A',X'1A'), ('1B',X'1B'), ('1C',X'1C'), ('1D',X'1D'), ('1E',X'1E'), ('1F',X'1F'),
			('20',X'20'), ('21',X'21'), ('22',X'22'), ('23',X'23'), ('24',X'24'), ('25',X'25'), ('26',X'26'), ('27',X'27'), ('28',X'28'),
			('29',X'29'), ('2A',X'2A'), ('2B',X'2B'), ('2C',X'2C'), ('2D',X'2D'), ('2E',X'2E'), ('2F',X'2F'), ('30',X'30'), ('31',X'31'),
			('32',X'32'), ('33',X'33'), ('34',X'34'), ('35',X'35'), ('36',X'36'), ('37',X'37'), ('38',X'38'), ('39',X'39'), ('3A',X'3A'),
			('3B',X'3B'), ('3C',X'3C'), ('3D',X'3D'), ('3E',X'3E'), ('3F',X'3F'), ('40',X'40'), ('41',X'41'), ('42',X'42'), ('43',X'43'),
			('44',X'44'), ('45',X'45'), ('46',X'46'), ('47',X'47'), ('48',X'48'), ('49',X'49'), ('4A',X'4A'), ('4B',X'4B'), ('4C',X'4C'),
			('4D',X'4D'), ('4E',X'4E'), ('4F',X'4F'), ('50',X'50'), ('51',X'51'), ('52',X'52'), ('53',X'53'), ('54',X'54'), ('55',X'55'),
			('56',X'56'), ('57',X'57'), ('58',X'58'), ('59',X'59'), ('5A',X'5A'), ('5B',X'5B'), ('5C',X'5C'), ('5D',X'5D'), ('5E',X'5E'),
			('5F',X'5F'), ('60',X'60'), ('61',X'61'), ('62',X'62'), ('63',X'63'), ('64',X'64'), ('65',X'65'), ('66',X'66'), ('67',X'67'),
			('68',X'68'), ('69',X'69'), ('6A',X'6A'), ('6B',X'6B'), ('6C',X'6C'), ('6D',X'6D'), ('6E',X'6E'), ('6F',X'6F'), ('70',X'70'),
			('71',X'71'), ('72',X'72'), ('73',X'73'), ('74',X'74'), ('75',X'75'), ('76',X'76'), ('77',X'77'), ('78',X'78'), ('79',X'79'),
			('7A',X'7A'), ('7B',X'7B'), ('7C',X'7C'), ('7D',X'7D'), ('7E',X'7E'), ('7F',X'7F'), ('80',X'80'), ('81',X'81'), ('82',X'82'),
			('83',X'83'), ('84',X'84'), ('85',X'85'), ('86',X'86'), ('87',X'87'), ('88',X'88'), ('89',X'89'), ('8A',X'8A'), ('8B',X'8B'),
			('8C',X'8C'), ('8D',X'8D'), ('8E',X'8E'), ('8F',X'8F'), ('90',X'90'), ('91',X'91'), ('92',X'92'), ('93',X'93'), ('94',X'94'),
			('95',X'95'), ('96',X'96'), ('97',X'97'), ('98',X'98'), ('99',X'99'), ('9A',X'9A'), ('9B',X'9B'), ('9C',X'9C'), ('9D',X'9D'),
			('9E',X'9E'), ('9F',X'9F'), ('A0',X'A0'), ('A1',X'A1'), ('A2',X'A2'), ('A3',X'A3'), ('A4',X'A4'), ('A5',X'A5'), ('A6',X'A6'),
			('A7',X'A7'), ('A8',X'A8'), ('A9',X'A9'), ('AA',X'AA'), ('AB',X'AB'), ('AC',X'AC'), ('AD',X'AD'), ('AE',X'AE'), ('AF',X'AF'),
			('B0',X'B0'), ('B1',X'B1'), ('B2',X'B2'), ('B3',X'B3'), ('B4',X'B4'), ('B5',X'B5'), ('B6',X'B6'), ('B7',X'B7'), ('B8',X'B8'),
			('B9',X'B9'), ('BA',X'BA'), ('BB',X'BB'), ('BC',X'BC'), ('BD',X'BD'), ('BE',X'BE'), ('BF',X'BF'), ('C0',X'C0'), ('C1',X'C1'),
			('C2',X'C2'), ('C3',X'C3'), ('C4',X'C4'), ('C5',X'C5'), ('C6',X'C6'), ('C7',X'C7'), ('C8',X'C8'), ('C9',X'C9'), ('CA',X'CA'),
			('CB',X'CB'), ('CC',X'CC'), ('CD',X'CD'), ('CE',X'CE'), ('CF',X'CF'), ('D0',X'D0'), ('D1',X'D1'), ('D2',X'D2'), ('D3',X'D3'),
			('D4',X'D4'), ('D5',X'D5'), ('D6',X'D6'), ('D7',X'D7'), ('D8',X'D8'), ('D9',X'D9'), ('DA',X'DA'), ('DB',X'DB'), ('DC',X'DC'),
			('DD',X'DD'), ('DE',X'DE'), ('DF',X'DF'), ('E0',X'E0'), ('E1',X'E1'), ('E2',X'E2'), ('E3',X'E3'), ('E4',X'E4'), ('E5',X'E5'),
			('E6',X'E6'), ('E7',X'E7'), ('E8',X'E8'), ('E9',X'E9'), ('EA',X'EA'), ('EB',X'EB'), ('EC',X'EC'), ('ED',X'ED'), ('EE',X'EE'),
			('EF',X'EF'), ('F0',X'F0'), ('F1',X'F1'), ('F2',X'F2'), ('F3',X'F3'), ('F4',X'F4'), ('F5',X'F5'), ('F6',X'F6'), ('F7',X'F7'),
			('F8',X'F8'), ('F9',X'F9'), ('FA',X'FA'), ('FB',X'FB'), ('FC',X'FC'), ('FD',X'FD'), ('FE',X'FE'), ('FF',X'FF');
		--pragma recursive_triggers=1;
		-- next line is a helper-macro for char_to_uuid
		#define unhex_byte(victim) (select b from _sqlite_unhexhack_lookup_tbl where h = victim)
		/*}}}*/
		#define UUID blob(16)
		/*{{{ uuid_to_char */
		#define uuid_to_char(victim) lower( \
					substr(hex(victim), 1,8) || '-' || \
					substr(hex(victim), 9,4) || '-' || \
					substr(hex(victim),13,4) || '-' || \
					substr(hex(victim),17,4) || '-' || \
					substr(hex(victim),21,12) )
		/*}}}*/
		#define uuid_to_hex(victim) lower(hex(victim))
		/*{{{ char_to_uuid */
		#define char_to_uuid(victim) cast( unhex_byte(substr(replace(victim,'-',''),1,2)) || \
			unhex_byte(substr(replace(victim,'-',''),3,2)) || \
			unhex_byte(substr(replace(victim,'-',''),5,2)) || \
			unhex_byte(substr(replace(victim,'-',''),7,2)) || \
			unhex_byte(substr(replace(victim,'-',''),9,2)) || \
			unhex_byte(substr(replace(victim,'-',''),11,2)) || \
			unhex_byte(substr(replace(victim,'-',''),13,2)) || \
			unhex_byte(substr(replace(victim,'-',''),15,2)) || \
			unhex_byte(substr(replace(victim,'-',''),17,2)) || \
			unhex_byte(substr(replace(victim,'-',''),19,2)) || \
			unhex_byte(substr(replace(victim,'-',''),21,2)) || \
			unhex_byte(substr(replace(victim,'-',''),23,2)) || \
			unhex_byte(substr(replace(victim,'-',''),25,2)) || \
			unhex_byte(substr(replace(victim,'-',''),27,2)) || \
			unhex_byte(substr(replace(victim,'-',''),29,2)) || \
			unhex_byte(substr(replace(victim,'-',''),31,2)) as blob)
		/*}}}*/
		#define NewID() (randomblob(16))
	/*}}}*/
	#else
		#error "No target database engine selected!"
	#endif /* engine selection */
#endif /* include guard */
